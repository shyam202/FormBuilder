{"ast":null,"code":"/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.3.3\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport Popper from 'popper.js';\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\n\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar DEFAULT_OPTIONS = {\n  container: false,\n  delay: 0,\n  html: false,\n  placement: 'top',\n  title: '',\n  template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n  trigger: 'hover focus',\n  offset: 0,\n  arrowSelector: '.tooltip-arrow, .tooltip__arrow',\n  innerSelector: '.tooltip-inner, .tooltip__inner'\n};\n\nvar Tooltip = function () {\n  /**\n   * Create a new Tooltip.js instance\n   * @class Tooltip\n   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).\n   * @param {Object} options\n   * @param {String} options.placement='top'\n   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),\n   *      left(-start, -end)`\n   * @param {String} [options.arrowSelector='.tooltip-arrow, .tooltip__arrow'] - className used to locate the DOM arrow element in the tooltip.\n   * @param {String} [options.innerSelector='.tooltip-inner, .tooltip__inner'] - className used to locate the DOM inner element in the tooltip.\n   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.\n   * @param {Number|Object} options.delay=0\n   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.\n   *      If a number is supplied, delay is applied to both hide/show.\n   *      Object structure is: `{ show: 500, hide: 100 }`\n   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `textContent`.\n   * @param {String} [options.template='<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>']\n   *      Base HTML to used when creating the tooltip.\n   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.\n   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.\n   *      The outermost wrapper element should have the `.tooltip` class.\n   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.\n   * @param {String} [options.trigger='hover focus']\n   *      How tooltip is triggered - click, hover, focus, manual.\n   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.\n   * @param {Boolean} options.closeOnClickOutside=false - Close a popper on click outside of the popper and reference element. This has effect only when options.trigger is 'click'.\n   * @param {String|HTMLElement} options.boundariesElement\n   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'\n   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)\n   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'\n   *      [offset docs](https://popper.js.org/popper-documentation.html)\n   * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'\n   *      [options docs](https://popper.js.org/popper-documentation.html)\n   * @return {Object} instance - The generated tooltip instance\n   */\n  function Tooltip(reference, options) {\n    classCallCheck(this, Tooltip);\n\n    _initialiseProps.call(this); // apply user options over default ones\n\n\n    options = _extends({}, DEFAULT_OPTIONS, options);\n    reference.jquery && (reference = reference[0]); // cache reference and options\n\n    this.reference = reference;\n    this.options = options; // get events list\n\n    var events = typeof options.trigger === 'string' ? options.trigger.split(' ').filter(function (trigger) {\n      return ['click', 'hover', 'focus'].indexOf(trigger) !== -1;\n    }) : []; // set initial state\n\n    this._isOpen = false;\n    this._popperOptions = {}; // set event listeners\n\n    this._setEventListeners(reference, events, options);\n  } //\n  // Public methods\n  //\n\n  /**\n   * Reveals an element's tooltip. This is considered a \"manual\" triggering of the tooltip.\n   * Tooltips with zero-length titles are never displayed.\n   * @method Tooltip#show\n   * @memberof Tooltip\n   */\n\n  /**\n   * Hides an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n   * @method Tooltip#hide\n   * @memberof Tooltip\n   */\n\n  /**\n   * Hides and destroys an element’s tooltip.\n   * @method Tooltip#dispose\n   * @memberof Tooltip\n   */\n\n  /**\n   * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n   * @method Tooltip#toggle\n   * @memberof Tooltip\n   */\n\n  /**\n   * Updates the tooltip's title content\n   * @method Tooltip#updateTitleContent\n   * @memberof Tooltip\n   * @param {String|HTMLElement} title - The new content to use for the title\n   */\n  //\n  // Private methods\n  //\n\n\n  createClass(Tooltip, [{\n    key: '_create',\n\n    /**\n     * Creates a new tooltip node\n     * @memberof Tooltip\n     * @private\n     * @param {HTMLElement} reference\n     * @param {String} template\n     * @param {String|HTMLElement|TitleFunction} title\n     * @param {Boolean} allowHtml\n     * @return {HTMLElement} tooltipNode\n     */\n    value: function _create(reference, template, title, allowHtml) {\n      // create tooltip element\n      var tooltipGenerator = window.document.createElement('div');\n      tooltipGenerator.innerHTML = template.trim();\n      var tooltipNode = tooltipGenerator.childNodes[0]; // add unique ID to our tooltip (needed for accessibility reasons)\n\n      tooltipNode.id = 'tooltip_' + Math.random().toString(36).substr(2, 10); // set initial `aria-hidden` state to `false` (it's visible!)\n\n      tooltipNode.setAttribute('aria-hidden', 'false'); // add title to tooltip\n\n      var titleNode = tooltipGenerator.querySelector(this.options.innerSelector);\n\n      this._addTitleContent(reference, title, allowHtml, titleNode); // return the generated tooltip node\n\n\n      return tooltipNode;\n    }\n  }, {\n    key: '_addTitleContent',\n    value: function _addTitleContent(reference, title, allowHtml, titleNode) {\n      if (title.nodeType === 1 || title.nodeType === 11) {\n        // if title is a element node or document fragment, append it only if allowHtml is true\n        allowHtml && titleNode.appendChild(title);\n      } else if (isFunction(title)) {\n        // Recursively call ourself so that the return value of the function gets handled appropriately - either\n        // as a dom node, a string, or even as another function.\n        this._addTitleContent(reference, title.call(reference), allowHtml, titleNode);\n      } else {\n        // if it's just a simple text, set textContent or innerHtml depending by `allowHtml` value\n        allowHtml ? titleNode.innerHTML = title : titleNode.textContent = title;\n      }\n    }\n  }, {\n    key: '_show',\n    value: function _show(reference, options) {\n      // don't show if it's already visible\n      // or if it's not being showed\n      if (this._isOpen && !this._isOpening) {\n        return this;\n      }\n\n      this._isOpen = true; // if the tooltipNode already exists, just show it\n\n      if (this._tooltipNode) {\n        this._tooltipNode.style.visibility = 'visible';\n\n        this._tooltipNode.setAttribute('aria-hidden', 'false');\n\n        this.popperInstance.update();\n        return this;\n      } // get title\n\n\n      var title = reference.getAttribute('title') || options.title; // don't show tooltip if no title is defined\n\n      if (!title) {\n        return this;\n      } // create tooltip node\n\n\n      var tooltipNode = this._create(reference, options.template, title, options.html); // Add `aria-describedby` to our reference element for accessibility reasons\n\n\n      reference.setAttribute('aria-describedby', tooltipNode.id); // append tooltip to container\n\n      var container = this._findContainer(options.container, reference);\n\n      this._append(tooltipNode, container);\n\n      this._popperOptions = _extends({}, options.popperOptions, {\n        placement: options.placement\n      });\n      this._popperOptions.modifiers = _extends({}, this._popperOptions.modifiers, {\n        arrow: _extends({}, this._popperOptions.modifiers && this._popperOptions.modifiers.arrow, {\n          element: options.arrowSelector\n        }),\n        offset: _extends({}, this._popperOptions.modifiers && this._popperOptions.modifiers.offset, {\n          offset: options.offset || this._popperOptions.modifiers && this._popperOptions.modifiers.offset && this._popperOptions.modifiers.offset.offset || options.offset\n        })\n      });\n\n      if (options.boundariesElement) {\n        this._popperOptions.modifiers.preventOverflow = {\n          boundariesElement: options.boundariesElement\n        };\n      }\n\n      this.popperInstance = new Popper(reference, tooltipNode, this._popperOptions);\n      this._tooltipNode = tooltipNode;\n      return this;\n    }\n  }, {\n    key: '_hide',\n    value: function _hide()\n    /*reference, options*/\n    {\n      // don't hide if it's already hidden\n      if (!this._isOpen) {\n        return this;\n      }\n\n      this._isOpen = false; // hide tooltipNode\n\n      this._tooltipNode.style.visibility = 'hidden';\n\n      this._tooltipNode.setAttribute('aria-hidden', 'true');\n\n      return this;\n    }\n  }, {\n    key: '_dispose',\n    value: function _dispose() {\n      var _this = this; // remove event listeners first to prevent any unexpected behaviour\n\n\n      this._events.forEach(function (_ref) {\n        var func = _ref.func,\n            event = _ref.event;\n\n        _this.reference.removeEventListener(event, func);\n      });\n\n      this._events = [];\n\n      if (this._tooltipNode) {\n        this._hide(); // destroy instance\n\n\n        this.popperInstance.destroy(); // destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element\n\n        if (!this.popperInstance.options.removeOnDestroy) {\n          this._tooltipNode.parentNode.removeChild(this._tooltipNode);\n\n          this._tooltipNode = null;\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: '_findContainer',\n    value: function _findContainer(container, reference) {\n      // if container is a query, get the relative element\n      if (typeof container === 'string') {\n        container = window.document.querySelector(container);\n      } else if (container === false) {\n        // if container is `false`, set it to reference parent\n        container = reference.parentNode;\n      }\n\n      return container;\n    }\n    /**\n     * Append tooltip to container\n     * @memberof Tooltip\n     * @private\n     * @param {HTMLElement} tooltipNode\n     * @param {HTMLElement|String|false} container\n     */\n\n  }, {\n    key: '_append',\n    value: function _append(tooltipNode, container) {\n      container.appendChild(tooltipNode);\n    }\n  }, {\n    key: '_setEventListeners',\n    value: function _setEventListeners(reference, events, options) {\n      var _this2 = this;\n\n      var directEvents = [];\n      var oppositeEvents = [];\n      events.forEach(function (event) {\n        switch (event) {\n          case 'hover':\n            directEvents.push('mouseenter');\n            oppositeEvents.push('mouseleave');\n            break;\n\n          case 'focus':\n            directEvents.push('focus');\n            oppositeEvents.push('blur');\n            break;\n\n          case 'click':\n            directEvents.push('click');\n            oppositeEvents.push('click');\n            break;\n        }\n      }); // schedule show tooltip\n\n      directEvents.forEach(function (event) {\n        var func = function func(evt) {\n          if (_this2._isOpening === true) {\n            return;\n          }\n\n          evt.usedByTooltip = true;\n\n          _this2._scheduleShow(reference, options.delay, options, evt);\n        };\n\n        _this2._events.push({\n          event: event,\n          func: func\n        });\n\n        reference.addEventListener(event, func);\n      }); // schedule hide tooltip\n\n      oppositeEvents.forEach(function (event) {\n        var func = function func(evt) {\n          if (evt.usedByTooltip === true) {\n            return;\n          }\n\n          _this2._scheduleHide(reference, options.delay, options, evt);\n        };\n\n        _this2._events.push({\n          event: event,\n          func: func\n        });\n\n        reference.addEventListener(event, func);\n\n        if (event === 'click' && options.closeOnClickOutside) {\n          document.addEventListener('mousedown', function (e) {\n            if (!_this2._isOpening) {\n              return;\n            }\n\n            var popper = _this2.popperInstance.popper;\n\n            if (reference.contains(e.target) || popper.contains(e.target)) {\n              return;\n            }\n\n            func(e);\n          }, true);\n        }\n      });\n    }\n  }, {\n    key: '_scheduleShow',\n    value: function _scheduleShow(reference, delay, options\n    /*, evt */\n    ) {\n      var _this3 = this;\n\n      this._isOpening = true; // defaults to 0\n\n      var computedDelay = delay && delay.show || delay || 0;\n      this._showTimeout = window.setTimeout(function () {\n        return _this3._show(reference, options);\n      }, computedDelay);\n    }\n  }, {\n    key: '_scheduleHide',\n    value: function _scheduleHide(reference, delay, options, evt) {\n      var _this4 = this;\n\n      this._isOpening = false; // defaults to 0\n\n      var computedDelay = delay && delay.hide || delay || 0;\n      window.clearTimeout(this._showTimeout);\n      window.setTimeout(function () {\n        if (_this4._isOpen === false) {\n          return;\n        }\n\n        if (!document.body.contains(_this4._tooltipNode)) {\n          return;\n        } // if we are hiding because of a mouseleave, we must check that the new\n        // reference isn't the tooltip, because in this case we don't want to hide it\n\n\n        if (evt.type === 'mouseleave') {\n          var isSet = _this4._setTooltipNodeEvent(evt, reference, delay, options); // if we set the new event, don't hide the tooltip yet\n          // the new event will take care to hide it if necessary\n\n\n          if (isSet) {\n            return;\n          }\n        }\n\n        _this4._hide(reference, options);\n      }, computedDelay);\n    }\n  }, {\n    key: '_updateTitleContent',\n    value: function _updateTitleContent(title) {\n      if (typeof this._tooltipNode === 'undefined') {\n        if (typeof this.options.title !== 'undefined') {\n          this.options.title = title;\n        }\n\n        return;\n      }\n\n      var titleNode = this._tooltipNode.querySelector(this.options.innerSelector);\n\n      this._clearTitleContent(titleNode, this.options.html, this.reference.getAttribute('title') || this.options.title);\n\n      this._addTitleContent(this.reference, title, this.options.html, titleNode);\n\n      this.options.title = title;\n      this.popperInstance.update();\n    }\n  }, {\n    key: '_clearTitleContent',\n    value: function _clearTitleContent(titleNode, allowHtml, lastTitle) {\n      if (lastTitle.nodeType === 1 || lastTitle.nodeType === 11) {\n        allowHtml && titleNode.removeChild(lastTitle);\n      } else {\n        allowHtml ? titleNode.innerHTML = '' : titleNode.textContent = '';\n      }\n    }\n  }]);\n  return Tooltip;\n}();\n/**\n * Title function, its context is the Tooltip instance.\n * @memberof Tooltip\n * @callback TitleFunction\n * @return {String} placement - The desired title.\n */\n\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this5 = this;\n\n  this.show = function () {\n    return _this5._show(_this5.reference, _this5.options);\n  };\n\n  this.hide = function () {\n    return _this5._hide();\n  };\n\n  this.dispose = function () {\n    return _this5._dispose();\n  };\n\n  this.toggle = function () {\n    if (_this5._isOpen) {\n      return _this5.hide();\n    } else {\n      return _this5.show();\n    }\n  };\n\n  this.updateTitleContent = function (title) {\n    return _this5._updateTitleContent(title);\n  };\n\n  this._events = [];\n\n  this._setTooltipNodeEvent = function (evt, reference, delay, options) {\n    var relatedreference = evt.relatedreference || evt.toElement || evt.relatedTarget;\n\n    var callback = function callback(evt2) {\n      var relatedreference2 = evt2.relatedreference || evt2.toElement || evt2.relatedTarget; // Remove event listener after call\n\n      _this5._tooltipNode.removeEventListener(evt.type, callback); // If the new reference is not the reference element\n\n\n      if (!reference.contains(relatedreference2)) {\n        // Schedule to hide tooltip\n        _this5._scheduleHide(reference, options.delay, options, evt2);\n      }\n    };\n\n    if (_this5._tooltipNode.contains(relatedreference)) {\n      // listen to mouseleave on the tooltip element to be able to hide the tooltip\n      _this5._tooltipNode.addEventListener(evt.type, callback);\n\n      return true;\n    }\n\n    return false;\n  };\n};\n\nexport default Tooltip;","map":{"version":3,"sources":["../../../popper/src/utils/isFunction.js","../../src/index.js"],"names":["getType","functionToCheck","DEFAULT_OPTIONS","Tooltip","reference","events","options","show","hide","dispose","toggle","updateTitleContent","_events","template","title","allowHtml","tooltipGenerator","window","tooltipNode","Math","titleNode","isFunction","container","placement","arrowSelector","offset","boundariesElement","func","event","directEvents","oppositeEvents","evt","popper","e","delay","computedDelay","document","isSet","_setTooltipNodeEvent","relatedreference","callback","relatedreference2","evt2","lastTitle"],"mappings":"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","sourcesContent":["/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n  const getType = {};\n  return (\n    functionToCheck &&\n    getType.toString.call(functionToCheck) === '[object Function]'\n  );\n}\n","import Popper from 'popper.js';\nimport isFunction from '../../popper/src/utils/isFunction';\n\nconst DEFAULT_OPTIONS = {\n  container: false,\n  delay: 0,\n  html: false,\n  placement: 'top',\n  title: '',\n  template:\n    '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n  trigger: 'hover focus',\n  offset: 0,\n  arrowSelector: '.tooltip-arrow, .tooltip__arrow',\n  innerSelector: '.tooltip-inner, .tooltip__inner',\n};\n\nexport default class Tooltip {\n  /**\n   * Create a new Tooltip.js instance\n   * @class Tooltip\n   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).\n   * @param {Object} options\n   * @param {String} options.placement='top'\n   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),\n   *      left(-start, -end)`\n   * @param {String} [options.arrowSelector='.tooltip-arrow, .tooltip__arrow'] - className used to locate the DOM arrow element in the tooltip.\n   * @param {String} [options.innerSelector='.tooltip-inner, .tooltip__inner'] - className used to locate the DOM inner element in the tooltip.\n   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.\n   * @param {Number|Object} options.delay=0\n   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.\n   *      If a number is supplied, delay is applied to both hide/show.\n   *      Object structure is: `{ show: 500, hide: 100 }`\n   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `textContent`.\n   * @param {String} [options.template='<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>']\n   *      Base HTML to used when creating the tooltip.\n   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.\n   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.\n   *      The outermost wrapper element should have the `.tooltip` class.\n   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.\n   * @param {String} [options.trigger='hover focus']\n   *      How tooltip is triggered - click, hover, focus, manual.\n   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.\n   * @param {Boolean} options.closeOnClickOutside=false - Close a popper on click outside of the popper and reference element. This has effect only when options.trigger is 'click'.\n   * @param {String|HTMLElement} options.boundariesElement\n   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'\n   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)\n   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'\n   *      [offset docs](https://popper.js.org/popper-documentation.html)\n   * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'\n   *      [options docs](https://popper.js.org/popper-documentation.html)\n   * @return {Object} instance - The generated tooltip instance\n   */\n  constructor(reference, options) {\n    // apply user options over default ones\n    options = { ...DEFAULT_OPTIONS, ...options };\n\n    reference.jquery && (reference = reference[0]);\n\n    // cache reference and options\n    this.reference = reference;\n    this.options = options;\n\n    // get events list\n    const events =\n      typeof options.trigger === 'string'\n        ? options.trigger\n            .split(' ')\n            .filter(\n              trigger => ['click', 'hover', 'focus'].indexOf(trigger) !== -1\n            )\n        : [];\n\n    // set initial state\n    this._isOpen = false;\n    this._popperOptions = {};\n\n    // set event listeners\n    this._setEventListeners(reference, events, options);\n  }\n\n  //\n  // Public methods\n  //\n\n  /**\n   * Reveals an element's tooltip. This is considered a \"manual\" triggering of the tooltip.\n   * Tooltips with zero-length titles are never displayed.\n   * @method Tooltip#show\n   * @memberof Tooltip\n   */\n  show = () => this._show(this.reference, this.options);\n\n  /**\n   * Hides an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n   * @method Tooltip#hide\n   * @memberof Tooltip\n   */\n  hide = () => this._hide();\n\n  /**\n   * Hides and destroys an element’s tooltip.\n   * @method Tooltip#dispose\n   * @memberof Tooltip\n   */\n  dispose = () => this._dispose();\n\n  /**\n   * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n   * @method Tooltip#toggle\n   * @memberof Tooltip\n   */\n  toggle = () => {\n    if (this._isOpen) {\n      return this.hide();\n    } else {\n      return this.show();\n    }\n  };\n\n  /**\n   * Updates the tooltip's title content\n   * @method Tooltip#updateTitleContent\n   * @memberof Tooltip\n   * @param {String|HTMLElement} title - The new content to use for the title\n   */\n  updateTitleContent = (title) => this._updateTitleContent(title);\n\n  //\n  // Private methods\n  //\n\n  _events = [];\n\n  /**\n   * Creates a new tooltip node\n   * @memberof Tooltip\n   * @private\n   * @param {HTMLElement} reference\n   * @param {String} template\n   * @param {String|HTMLElement|TitleFunction} title\n   * @param {Boolean} allowHtml\n   * @return {HTMLElement} tooltipNode\n   */\n  _create(reference, template, title, allowHtml) {\n    // create tooltip element\n    const tooltipGenerator = window.document.createElement('div');\n    tooltipGenerator.innerHTML = template.trim();\n    const tooltipNode = tooltipGenerator.childNodes[0];\n\n    // add unique ID to our tooltip (needed for accessibility reasons)\n    tooltipNode.id = `tooltip_${Math.random()\n      .toString(36)\n      .substr(2, 10)}`;\n\n    // set initial `aria-hidden` state to `false` (it's visible!)\n    tooltipNode.setAttribute('aria-hidden', 'false');\n\n    // add title to tooltip\n    const titleNode = tooltipGenerator.querySelector(this.options.innerSelector);\n    this._addTitleContent(reference, title, allowHtml, titleNode);\n\n    // return the generated tooltip node\n    return tooltipNode;\n  }\n\n  _addTitleContent(reference, title, allowHtml, titleNode) {\n    if (title.nodeType === 1 || title.nodeType === 11) {\n      // if title is a element node or document fragment, append it only if allowHtml is true\n      allowHtml && titleNode.appendChild(title);\n    } else if (isFunction(title)) {\n      // Recursively call ourself so that the return value of the function gets handled appropriately - either\n      // as a dom node, a string, or even as another function.\n      this._addTitleContent(reference, title.call(reference), allowHtml, titleNode);\n    } else {\n      // if it's just a simple text, set textContent or innerHtml depending by `allowHtml` value\n      allowHtml ? (titleNode.innerHTML = title) : (titleNode.textContent = title);\n    }\n  }\n\n  _show(reference, options) {\n    // don't show if it's already visible\n    // or if it's not being showed\n    if (this._isOpen && !this._isOpening) {\n      return this;\n    }\n    this._isOpen = true;\n\n    // if the tooltipNode already exists, just show it\n    if (this._tooltipNode) {\n      this._tooltipNode.style.visibility = 'visible';\n      this._tooltipNode.setAttribute('aria-hidden', 'false');\n      this.popperInstance.update();\n      return this;\n    }\n\n    // get title\n    const title = reference.getAttribute('title') || options.title;\n\n    // don't show tooltip if no title is defined\n    if (!title) {\n      return this;\n    }\n\n    // create tooltip node\n    const tooltipNode = this._create(\n      reference,\n      options.template,\n      title,\n      options.html\n    );\n\n    // Add `aria-describedby` to our reference element for accessibility reasons\n    reference.setAttribute('aria-describedby', tooltipNode.id);\n\n    // append tooltip to container\n    const container = this._findContainer(options.container, reference);\n\n    this._append(tooltipNode, container);\n\n    this._popperOptions = {\n      ...options.popperOptions,\n      placement: options.placement,\n    };\n\n    this._popperOptions.modifiers = {\n      ...this._popperOptions.modifiers,\n      arrow: {\n        ...(this._popperOptions.modifiers && this._popperOptions.modifiers.arrow),\n        element: options.arrowSelector,\n      },\n      offset: {\n        ...(this._popperOptions.modifiers && this._popperOptions.modifiers.offset),\n        offset: options.offset ||\n          this._popperOptions.modifiers && this._popperOptions.modifiers.offset && this._popperOptions.modifiers.offset.offset ||\n          options.offset,\n      },\n    };\n\n    if (options.boundariesElement) {\n      this._popperOptions.modifiers.preventOverflow = {\n        boundariesElement: options.boundariesElement,\n      };\n    }\n\n    this.popperInstance = new Popper(\n      reference,\n      tooltipNode,\n      this._popperOptions\n    );\n\n    this._tooltipNode = tooltipNode;\n\n    return this;\n  }\n\n  _hide(/*reference, options*/) {\n    // don't hide if it's already hidden\n    if (!this._isOpen) {\n      return this;\n    }\n\n    this._isOpen = false;\n\n    // hide tooltipNode\n    this._tooltipNode.style.visibility = 'hidden';\n    this._tooltipNode.setAttribute('aria-hidden', 'true');\n\n    return this;\n  }\n\n  _dispose() {\n    // remove event listeners first to prevent any unexpected behaviour\n    this._events.forEach(({ func, event }) => {\n      this.reference.removeEventListener(event, func);\n    });\n    this._events = [];\n\n    if (this._tooltipNode) {\n      this._hide();\n\n      // destroy instance\n      this.popperInstance.destroy();\n\n      // destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element\n      if (!this.popperInstance.options.removeOnDestroy) {\n        this._tooltipNode.parentNode.removeChild(this._tooltipNode);\n        this._tooltipNode = null;\n      }\n    }\n    return this;\n  }\n\n  _findContainer(container, reference) {\n    // if container is a query, get the relative element\n    if (typeof container === 'string') {\n      container = window.document.querySelector(container);\n    } else if (container === false) {\n      // if container is `false`, set it to reference parent\n      container = reference.parentNode;\n    }\n    return container;\n  }\n\n  /**\n   * Append tooltip to container\n   * @memberof Tooltip\n   * @private\n   * @param {HTMLElement} tooltipNode\n   * @param {HTMLElement|String|false} container\n   */\n  _append(tooltipNode, container) {\n    container.appendChild(tooltipNode);\n  }\n\n  _setEventListeners(reference, events, options) {\n    const directEvents = [];\n    const oppositeEvents = [];\n\n    events.forEach(event => {\n      switch (event) {\n        case 'hover':\n          directEvents.push('mouseenter');\n          oppositeEvents.push('mouseleave');\n          break;\n        case 'focus':\n          directEvents.push('focus');\n          oppositeEvents.push('blur');\n          break;\n        case 'click':\n          directEvents.push('click');\n          oppositeEvents.push('click');\n          break;\n      }\n    });\n\n    // schedule show tooltip\n    directEvents.forEach(event => {\n      const func = evt => {\n        if (this._isOpening === true) {\n          return;\n        }\n        evt.usedByTooltip = true;\n        this._scheduleShow(reference, options.delay, options, evt);\n      };\n      this._events.push({ event, func });\n      reference.addEventListener(event, func);\n    });\n\n    // schedule hide tooltip\n    oppositeEvents.forEach(event => {\n      const func = evt => {\n        if (evt.usedByTooltip === true) {\n          return;\n        }\n        this._scheduleHide(reference, options.delay, options, evt);\n      };\n      this._events.push({ event, func });\n      reference.addEventListener(event, func);\n      if (event === 'click' && options.closeOnClickOutside) {\n        document.addEventListener('mousedown', e => {\n          if (!this._isOpening) {\n            return;\n          }\n          const popper = this.popperInstance.popper;\n          if (reference.contains(e.target) ||\n              popper.contains(e.target)) {\n            return;\n          }\n          func(e);\n        }, true);\n      }\n    });\n  }\n\n  _scheduleShow(reference, delay, options /*, evt */) {\n    this._isOpening = true;\n    // defaults to 0\n    const computedDelay = (delay && delay.show) || delay || 0;\n    this._showTimeout = window.setTimeout(\n      () => this._show(reference, options),\n      computedDelay\n    );\n  }\n\n  _scheduleHide(reference, delay, options, evt) {\n    this._isOpening = false;\n    // defaults to 0\n    const computedDelay = (delay && delay.hide) || delay || 0;\n    window.clearTimeout(this._showTimeout);\n    window.setTimeout(() => {\n      if (this._isOpen === false) {\n        return;\n      }\n      if (!document.body.contains(this._tooltipNode)) {\n        return;\n      }\n\n      // if we are hiding because of a mouseleave, we must check that the new\n      // reference isn't the tooltip, because in this case we don't want to hide it\n      if (evt.type === 'mouseleave') {\n        const isSet = this._setTooltipNodeEvent(evt, reference, delay, options);\n\n        // if we set the new event, don't hide the tooltip yet\n        // the new event will take care to hide it if necessary\n        if (isSet) {\n          return;\n        }\n      }\n\n      this._hide(reference, options);\n    }, computedDelay);\n  }\n\n  _setTooltipNodeEvent = (evt, reference, delay, options) => {\n    const relatedreference =\n      evt.relatedreference || evt.toElement || evt.relatedTarget;\n\n    const callback = evt2 => {\n      const relatedreference2 =\n        evt2.relatedreference || evt2.toElement || evt2.relatedTarget;\n\n      // Remove event listener after call\n      this._tooltipNode.removeEventListener(evt.type, callback);\n\n      // If the new reference is not the reference element\n      if (!reference.contains(relatedreference2)) {\n        // Schedule to hide tooltip\n        this._scheduleHide(reference, options.delay, options, evt2);\n      }\n    };\n\n    if (this._tooltipNode.contains(relatedreference)) {\n      // listen to mouseleave on the tooltip element to be able to hide the tooltip\n      this._tooltipNode.addEventListener(evt.type, callback);\n      return true;\n    }\n\n    return false;\n  };\n\n  _updateTitleContent(title) {\n    if(typeof this._tooltipNode === 'undefined') {\n      if(typeof this.options.title !== 'undefined') {\n        this.options.title = title;\n      }\n      return;\n    }\n    const titleNode = this._tooltipNode.querySelector(this.options.innerSelector);\n    this._clearTitleContent(titleNode, this.options.html, this.reference.getAttribute('title') || this.options.title)\n    this._addTitleContent(this.reference, title, this.options.html, titleNode);\n    this.options.title = title;\n    this.popperInstance.update();\n  }\n\n  _clearTitleContent(titleNode, allowHtml, lastTitle) {\n    if(lastTitle.nodeType === 1 || lastTitle.nodeType === 11) {\n      allowHtml && titleNode.removeChild(lastTitle);\n    } else {\n      allowHtml ? titleNode.innerHTML = '' : titleNode.textContent = '';\n    }\n  }\n\n}\n\n/**\n * Title function, its context is the Tooltip instance.\n * @memberof Tooltip\n * @callback TitleFunction\n * @return {String} placement - The desired title.\n */\n"]},"metadata":{},"sourceType":"module"}