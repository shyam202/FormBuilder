{"ast":null,"code":"/* global define */\n(function (root, factory) {\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.compareVersions = factory();\n  }\n})(this, function () {\n  var semver = /^v?(?:\\d+)(\\.(?:[x*]|\\d+)(\\.(?:[x*]|\\d+)(\\.(?:[x*]|\\d+))?(?:-[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\n  function indexOrEnd(str, q) {\n    return str.indexOf(q) === -1 ? str.length : str.indexOf(q);\n  }\n\n  function split(v) {\n    var c = v.replace(/^v/, '').replace(/\\+.*$/, '');\n    var patchIndex = indexOrEnd(c, '-');\n    var arr = c.substring(0, patchIndex).split('.');\n    arr.push(c.substring(patchIndex + 1));\n    return arr;\n  }\n\n  function tryParse(v) {\n    return isNaN(Number(v)) ? v : Number(v);\n  }\n\n  function validate(version) {\n    if (typeof version !== 'string') {\n      throw new TypeError('Invalid argument expected string');\n    }\n\n    if (!semver.test(version)) {\n      throw new Error('Invalid argument not valid semver (\\'' + version + '\\' received)');\n    }\n  }\n\n  function compareVersions(v1, v2) {\n    [v1, v2].forEach(validate);\n    var s1 = split(v1);\n    var s2 = split(v2);\n\n    for (var i = 0; i < Math.max(s1.length - 1, s2.length - 1); i++) {\n      var n1 = parseInt(s1[i] || 0, 10);\n      var n2 = parseInt(s2[i] || 0, 10);\n      if (n1 > n2) return 1;\n      if (n2 > n1) return -1;\n    }\n\n    var sp1 = s1[s1.length - 1];\n    var sp2 = s2[s2.length - 1];\n\n    if (sp1 && sp2) {\n      var p1 = sp1.split('.').map(tryParse);\n      var p2 = sp2.split('.').map(tryParse);\n\n      for (i = 0; i < Math.max(p1.length, p2.length); i++) {\n        if (p1[i] === undefined || typeof p2[i] === 'string' && typeof p1[i] === 'number') return -1;\n        if (p2[i] === undefined || typeof p1[i] === 'string' && typeof p2[i] === 'number') return 1;\n        if (p1[i] > p2[i]) return 1;\n        if (p2[i] > p1[i]) return -1;\n      }\n    } else if (sp1 || sp2) {\n      return sp1 ? -1 : 1;\n    }\n\n    return 0;\n  }\n\n  ;\n  var allowedOperators = ['>', '>=', '=', '<', '<='];\n  var operatorResMap = {\n    '>': [1],\n    '>=': [0, 1],\n    '=': [0],\n    '<=': [-1, 0],\n    '<': [-1]\n  };\n\n  function validateOperator(op) {\n    if (typeof op !== 'string') {\n      throw new TypeError('Invalid operator type, expected string but got ' + typeof op);\n    }\n\n    if (allowedOperators.indexOf(op) === -1) {\n      throw new TypeError('Invalid operator, expected one of ' + allowedOperators.join('|'));\n    }\n  }\n\n  compareVersions.validate = function (version) {\n    return typeof version === 'string' && semver.test(version);\n  };\n\n  compareVersions.compare = function (v1, v2, operator) {\n    // Validate operator\n    validateOperator(operator); // since result of compareVersions can only be -1 or 0 or 1\n    // a simple map can be used to replace switch\n\n    var res = compareVersions(v1, v2);\n    return operatorResMap[operator].indexOf(res) > -1;\n  };\n\n  return compareVersions;\n});","map":{"version":3,"sources":["C:/Users/ShyamLakhani/Desktop/my-app/node_modules/compare-versions/index.js"],"names":["root","factory","define","amd","exports","module","compareVersions","semver","indexOrEnd","str","q","indexOf","length","split","v","c","replace","patchIndex","arr","substring","push","tryParse","isNaN","Number","validate","version","TypeError","test","Error","v1","v2","forEach","s1","s2","i","Math","max","n1","parseInt","n2","sp1","sp2","p1","map","p2","undefined","allowedOperators","operatorResMap","validateOperator","op","join","compare","operator","res"],"mappings":"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","sourcesContent":["/* global define */\n(function (root, factory) {\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.compareVersions = factory();\n  }\n}(this, function () {\n\n  var semver = /^v?(?:\\d+)(\\.(?:[x*]|\\d+)(\\.(?:[x*]|\\d+)(\\.(?:[x*]|\\d+))?(?:-[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\n  function indexOrEnd(str, q) {\n    return str.indexOf(q) === -1 ? str.length : str.indexOf(q);\n  }\n\n  function split(v) {\n    var c = v.replace(/^v/, '').replace(/\\+.*$/, '');\n    var patchIndex = indexOrEnd(c, '-');\n    var arr = c.substring(0, patchIndex).split('.');\n    arr.push(c.substring(patchIndex + 1));\n    return arr;\n  }\n\n  function tryParse(v) {\n    return isNaN(Number(v)) ? v : Number(v);\n  }\n\n  function validate(version) {\n    if (typeof version !== 'string') {\n      throw new TypeError('Invalid argument expected string');\n    }\n    if (!semver.test(version)) {\n      throw new Error('Invalid argument not valid semver (\\''+version+'\\' received)');\n    }\n  }\n\n  function compareVersions(v1, v2) {\n    [v1, v2].forEach(validate);\n\n    var s1 = split(v1);\n    var s2 = split(v2);\n\n    for (var i = 0; i < Math.max(s1.length - 1, s2.length - 1); i++) {\n      var n1 = parseInt(s1[i] || 0, 10);\n      var n2 = parseInt(s2[i] || 0, 10);\n\n      if (n1 > n2) return 1;\n      if (n2 > n1) return -1;\n    }\n\n    var sp1 = s1[s1.length - 1];\n    var sp2 = s2[s2.length - 1];\n\n    if (sp1 && sp2) {\n      var p1 = sp1.split('.').map(tryParse);\n      var p2 = sp2.split('.').map(tryParse);\n\n      for (i = 0; i < Math.max(p1.length, p2.length); i++) {\n        if (p1[i] === undefined || typeof p2[i] === 'string' && typeof p1[i] === 'number') return -1;\n        if (p2[i] === undefined || typeof p1[i] === 'string' && typeof p2[i] === 'number') return 1;\n\n        if (p1[i] > p2[i]) return 1;\n        if (p2[i] > p1[i]) return -1;\n      }\n    } else if (sp1 || sp2) {\n      return sp1 ? -1 : 1;\n    }\n\n    return 0;\n  };\n\n  var allowedOperators = [\n    '>',\n    '>=',\n    '=',\n    '<',\n    '<='\n  ];\n\n  var operatorResMap = {\n    '>': [1],\n    '>=': [0, 1],\n    '=': [0],\n    '<=': [-1, 0],\n    '<': [-1]\n  };\n\n  function validateOperator(op) {\n    if (typeof op !== 'string') {\n      throw new TypeError('Invalid operator type, expected string but got ' + typeof op);\n    }\n    if (allowedOperators.indexOf(op) === -1) {\n      throw new TypeError('Invalid operator, expected one of ' + allowedOperators.join('|'));\n    }\n  }\n\n  compareVersions.validate = function(version) {\n    return typeof version === 'string' && semver.test(version);\n  }\n\n  compareVersions.compare = function (v1, v2, operator) {\n    // Validate operator\n    validateOperator(operator);\n\n    // since result of compareVersions can only be -1 or 0 or 1\n    // a simple map can be used to replace switch\n    var res = compareVersions(v1, v2);\n    return operatorResMap[operator].indexOf(res) > -1;\n  }\n\n  return compareVersions;\n}));\n"]},"metadata":{},"sourceType":"script"}