{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.autocomplete = factory());\n})(this, function () {\n  'use strict';\n  /*\r\n   * https://github.com/kraaden/autocomplete\r\n   * Copyright (c) 2016 Denys Krasnoshchok\r\n   * MIT License\r\n   */\n\n  function autocomplete(settings) {\n    // just an alias to minimize JS file size\n    var doc = document;\n    var container = doc.createElement(\"div\");\n    var containerStyle = container.style;\n    var userAgent = navigator.userAgent;\n    var mobileFirefox = userAgent.indexOf(\"Firefox\") !== -1 && userAgent.indexOf(\"Mobile\") !== -1;\n    var debounceWaitMs = settings.debounceWaitMs || 0;\n    var preventSubmit = settings.preventSubmit || false;\n    var disableAutoSelect = settings.disableAutoSelect || false; // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\n\n    var keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\n    var items = [];\n    var inputValue = \"\";\n    var minLen = 2;\n    var showOnFocus = settings.showOnFocus;\n    var selected;\n    var keypressCounter = 0;\n    var debounceTimer;\n\n    if (settings.minLength !== undefined) {\n      minLen = settings.minLength;\n    }\n\n    if (!settings.input) {\n      throw new Error(\"input undefined\");\n    }\n\n    var input = settings.input;\n    container.className = \"autocomplete \" + (settings.className || \"\"); // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\n\n    containerStyle.position = \"absolute\";\n    /**\r\n     * Detach the container from DOM\r\n     */\n\n    function detach() {\n      var parent = container.parentNode;\n\n      if (parent) {\n        parent.removeChild(container);\n      }\n    }\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\n\n\n    function clearDebounceTimer() {\n      if (debounceTimer) {\n        window.clearTimeout(debounceTimer);\n      }\n    }\n    /**\r\n     * Attach the container to DOM\r\n     */\n\n\n    function attach() {\n      if (!container.parentNode) {\n        doc.body.appendChild(container);\n      }\n    }\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\n\n\n    function containerDisplayed() {\n      return !!container.parentNode;\n    }\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\n\n\n    function clear() {\n      // prevent the update call if there are pending AJAX requests\n      keypressCounter++;\n      items = [];\n      inputValue = \"\";\n      selected = undefined;\n      detach();\n    }\n    /**\r\n     * Update autocomplete position\r\n     */\n\n\n    function updatePosition() {\n      if (!containerDisplayed()) {\n        return;\n      }\n\n      containerStyle.height = \"auto\";\n      containerStyle.width = input.offsetWidth + \"px\";\n      var maxHeight = 0;\n      var inputRect;\n\n      function calc() {\n        var docEl = doc.documentElement;\n        var clientTop = docEl.clientTop || doc.body.clientTop || 0;\n        var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;\n        var scrollTop = window.pageYOffset || docEl.scrollTop;\n        var scrollLeft = window.pageXOffset || docEl.scrollLeft;\n        inputRect = input.getBoundingClientRect();\n        var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;\n        var left = inputRect.left + scrollLeft - clientLeft;\n        containerStyle.top = top + \"px\";\n        containerStyle.left = left + \"px\";\n        maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\n\n        if (maxHeight < 0) {\n          maxHeight = 0;\n        }\n\n        containerStyle.top = top + \"px\";\n        containerStyle.bottom = \"\";\n        containerStyle.left = left + \"px\";\n        containerStyle.maxHeight = maxHeight + \"px\";\n      } // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)\n\n\n      calc();\n      calc();\n\n      if (settings.customize && inputRect) {\n        settings.customize(input, inputRect, container, maxHeight);\n      }\n    }\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\n\n\n    function update() {\n      // delete all children from autocomplete DOM container\n      while (container.firstChild) {\n        container.removeChild(container.firstChild);\n      } // function for rendering autocomplete suggestions\n\n\n      var render = function (item, currentValue) {\n        var itemElement = doc.createElement(\"div\");\n        itemElement.textContent = item.label || \"\";\n        return itemElement;\n      };\n\n      if (settings.render) {\n        render = settings.render;\n      } // function to render autocomplete groups\n\n\n      var renderGroup = function (groupName, currentValue) {\n        var groupDiv = doc.createElement(\"div\");\n        groupDiv.textContent = groupName;\n        return groupDiv;\n      };\n\n      if (settings.renderGroup) {\n        renderGroup = settings.renderGroup;\n      }\n\n      var fragment = doc.createDocumentFragment();\n      var prevGroup = \"#9?$\";\n      items.forEach(function (item) {\n        if (item.group && item.group !== prevGroup) {\n          prevGroup = item.group;\n          var groupDiv = renderGroup(item.group, inputValue);\n\n          if (groupDiv) {\n            groupDiv.className += \" group\";\n            fragment.appendChild(groupDiv);\n          }\n        }\n\n        var div = render(item, inputValue);\n\n        if (div) {\n          div.addEventListener(\"click\", function (ev) {\n            settings.onSelect(item, input);\n            clear();\n            ev.preventDefault();\n            ev.stopPropagation();\n          });\n\n          if (item === selected) {\n            div.className += \" selected\";\n          }\n\n          fragment.appendChild(div);\n        }\n      });\n      container.appendChild(fragment);\n\n      if (items.length < 1) {\n        if (settings.emptyMsg) {\n          var empty = doc.createElement(\"div\");\n          empty.className = \"empty\";\n          empty.textContent = settings.emptyMsg;\n          container.appendChild(empty);\n        } else {\n          clear();\n          return;\n        }\n      }\n\n      attach();\n      updatePosition();\n      updateScroll();\n    }\n\n    function updateIfDisplayed() {\n      if (containerDisplayed()) {\n        update();\n      }\n    }\n\n    function resizeEventHandler() {\n      updateIfDisplayed();\n    }\n\n    function scrollEventHandler(e) {\n      if (e.target !== container) {\n        updateIfDisplayed();\n      } else {\n        e.preventDefault();\n      }\n    }\n\n    function keyupEventHandler(ev) {\n      var keyCode = ev.which || ev.keyCode || 0;\n      var ignore = [38\n      /* Up */\n      , 13\n      /* Enter */\n      , 27\n      /* Esc */\n      , 39\n      /* Right */\n      , 37\n      /* Left */\n      , 16\n      /* Shift */\n      , 17\n      /* Ctrl */\n      , 18\n      /* Alt */\n      , 20\n      /* CapsLock */\n      , 91\n      /* WindowsKey */\n      , 9\n      /* Tab */\n      ];\n\n      for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {\n        var key = ignore_1[_i];\n\n        if (keyCode === key) {\n          return;\n        }\n      }\n\n      if (keyCode >= 112\n      /* F1 */\n      && keyCode <= 123\n      /* F12 */\n      ) {\n          return;\n        } // the down key is used to open autocomplete\n\n\n      if (keyCode === 40\n      /* Down */\n      && containerDisplayed()) {\n        return;\n      }\n\n      startFetch(0\n      /* Keyboard */\n      );\n    }\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\n\n\n    function updateScroll() {\n      var elements = container.getElementsByClassName(\"selected\");\n\n      if (elements.length > 0) {\n        var element = elements[0]; // make group visible\n\n        var previous = element.previousElementSibling;\n\n        if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\n          element = previous;\n        }\n\n        if (element.offsetTop < container.scrollTop) {\n          container.scrollTop = element.offsetTop;\n        } else {\n          var selectBottom = element.offsetTop + element.offsetHeight;\n          var containerBottom = container.scrollTop + container.offsetHeight;\n\n          if (selectBottom > containerBottom) {\n            container.scrollTop += selectBottom - containerBottom;\n          }\n        }\n      }\n    }\n    /**\r\n     * Select the previous item in suggestions\r\n     */\n\n\n    function selectPrev() {\n      if (items.length < 1) {\n        selected = undefined;\n      } else {\n        if (selected === items[0]) {\n          selected = items[items.length - 1];\n        } else {\n          for (var i = items.length - 1; i > 0; i--) {\n            if (selected === items[i] || i === 1) {\n              selected = items[i - 1];\n              break;\n            }\n          }\n        }\n      }\n    }\n    /**\r\n     * Select the next item in suggestions\r\n     */\n\n\n    function selectNext() {\n      if (items.length < 1) {\n        selected = undefined;\n      }\n\n      if (!selected || selected === items[items.length - 1]) {\n        selected = items[0];\n        return;\n      }\n\n      for (var i = 0; i < items.length - 1; i++) {\n        if (selected === items[i]) {\n          selected = items[i + 1];\n          break;\n        }\n      }\n    }\n\n    function keydownEventHandler(ev) {\n      var keyCode = ev.which || ev.keyCode || 0;\n\n      if (keyCode === 38\n      /* Up */\n      || keyCode === 40\n      /* Down */\n      || keyCode === 27\n      /* Esc */\n      ) {\n          var containerIsDisplayed = containerDisplayed();\n\n          if (keyCode === 27\n          /* Esc */\n          ) {\n              clear();\n            } else {\n            if (!containerIsDisplayed || items.length < 1) {\n              return;\n            }\n\n            keyCode === 38\n            /* Up */\n            ? selectPrev() : selectNext();\n            update();\n          }\n\n          ev.preventDefault();\n\n          if (containerIsDisplayed) {\n            ev.stopPropagation();\n          }\n\n          return;\n        }\n\n      if (keyCode === 13\n      /* Enter */\n      ) {\n          if (selected) {\n            settings.onSelect(selected, input);\n            clear();\n          }\n\n          if (preventSubmit) {\n            ev.preventDefault();\n          }\n        }\n    }\n\n    function focusEventHandler() {\n      if (showOnFocus) {\n        startFetch(1\n        /* Focus */\n        );\n      }\n    }\n\n    function startFetch(trigger) {\n      // If multiple keys were pressed, before we get an update from server,\n      // this may cause redrawing autocomplete multiple times after the last key was pressed.\n      // To avoid this, the number of times keyboard was pressed will be saved and checked before redraw.\n      var savedKeypressCounter = ++keypressCounter;\n      var val = input.value;\n\n      if (val.length >= minLen || trigger === 1\n      /* Focus */\n      ) {\n          clearDebounceTimer();\n          debounceTimer = window.setTimeout(function () {\n            settings.fetch(val, function (elements) {\n              if (keypressCounter === savedKeypressCounter && elements) {\n                items = elements;\n                inputValue = val;\n                selected = items.length < 1 || disableAutoSelect ? undefined : items[0];\n                update();\n              }\n            }, trigger);\n          }, trigger === 0\n          /* Keyboard */\n          ? debounceWaitMs : 0);\n        } else {\n        clear();\n      }\n    }\n\n    function blurEventHandler() {\n      // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n      setTimeout(function () {\n        if (doc.activeElement !== input) {\n          clear();\n        }\n      }, 200);\n    }\n    /**\r\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\r\n     */\n\n\n    container.addEventListener(\"mousedown\", function (evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n    });\n    /**\r\n     * Fixes #30: autocomplete closes when scrollbar is clicked in IE\r\n     * See: https://stackoverflow.com/a/9210267/13172349\r\n     */\n\n    container.addEventListener(\"focus\", function () {\n      return input.focus();\n    });\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\n\n    function destroy() {\n      input.removeEventListener(\"focus\", focusEventHandler);\n      input.removeEventListener(\"keydown\", keydownEventHandler);\n      input.removeEventListener(keyUpEventName, keyupEventHandler);\n      input.removeEventListener(\"blur\", blurEventHandler);\n      window.removeEventListener(\"resize\", resizeEventHandler);\n      doc.removeEventListener(\"scroll\", scrollEventHandler, true);\n      clearDebounceTimer();\n      clear();\n    } // setup event handlers\n\n\n    input.addEventListener(\"keydown\", keydownEventHandler);\n    input.addEventListener(keyUpEventName, keyupEventHandler);\n    input.addEventListener(\"blur\", blurEventHandler);\n    input.addEventListener(\"focus\", focusEventHandler);\n    window.addEventListener(\"resize\", resizeEventHandler);\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\n    return {\n      destroy: destroy\n    };\n  }\n\n  return autocomplete;\n});","map":{"version":3,"sources":["autocomplete.ts"],"names":[],"mappings":"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","sourcesContent":[" /*\r\n  * https://github.com/kraaden/autocomplete\r\n  * Copyright (c) 2016 Denys Krasnoshchok\r\n  * MIT License\r\n  */\r\n\r\nexport const enum EventTrigger {\r\n    Keyboard = 0,\r\n    Focus = 1\r\n}\r\n\r\nexport interface AutocompleteItem {\r\n    label?: string;\r\n    group?: string;\r\n}\r\n\r\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\r\n    input: HTMLInputElement;\r\n    render?: (item: T, currentValue: string) => HTMLDivElement | undefined;\r\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\r\n    className?: string;\r\n    minLength?: number;\r\n    emptyMsg?: string;\r\n    onSelect: (item: T, input: HTMLInputElement) => void;\r\n    /**\r\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\r\n     */\r\n    showOnFocus?: boolean;\r\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger) => void;\r\n    debounceWaitMs?: number;\r\n    /**\r\n     * Callback for additional autocomplete customization\r\n     * @param {HTMLInputElement} input - input box associated with autocomplete\r\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\r\n     * @param {HTMLDivElement} container - container with suggestions\r\n     * @param {number} maxHeight - max height that can be used by autocomplete\r\n     */\r\n    customize?: (input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\r\n    /**\r\n     * Prevents automatic form submit when ENTER is pressed\r\n     */\r\n    preventSubmit?: boolean;\r\n    /**\r\n     * Prevents the first item in the list from being selected automatically. This option allows you\r\n     * to submit a custom text by pressing ENTER even when autocomplete is displayed.\r\n     */\r\n    disableAutoSelect?: boolean;\r\n}\r\n\r\nexport interface AutocompleteResult {\r\n    destroy: () => void;\r\n}\r\n\r\nconst enum Keys {\r\n    Enter = 13,\r\n    Esc = 27,\r\n    Up = 38,\r\n    Down = 40,\r\n    Left = 37,\r\n    Right = 39,\r\n    Shift = 16,\r\n    Ctrl = 17,\r\n    Alt = 18,\r\n    CapsLock = 20,\r\n    WindowsKey = 91,\r\n    Tab = 9,\r\n    F1 = 112,\r\n    F12 = 123\r\n}\r\n\r\nexport default function autocomplete<T extends AutocompleteItem>(settings: AutocompleteSettings<T>): AutocompleteResult {\r\n\r\n    // just an alias to minimize JS file size\r\n    const doc = document;\r\n\r\n    const container: HTMLDivElement = doc.createElement(\"div\");\r\n    const containerStyle = container.style;\r\n    const userAgent = navigator.userAgent;\r\n    const mobileFirefox = userAgent.indexOf(\"Firefox\") !== -1 && userAgent.indexOf(\"Mobile\") !== -1;\r\n    const debounceWaitMs = settings.debounceWaitMs || 0;\r\n    const preventSubmit = settings.preventSubmit || false;\r\n    const disableAutoSelect = settings.disableAutoSelect || false;\r\n    \r\n    // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\r\n    const keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\r\n    \r\n    let items: T[] = [];\r\n    let inputValue = \"\";\r\n    let minLen = 2;\r\n    const showOnFocus = settings.showOnFocus;\r\n    let selected: T | undefined;\r\n    let keypressCounter = 0;\r\n    let debounceTimer : number | undefined;\r\n\r\n    if (settings.minLength !== undefined) {\r\n        minLen = settings.minLength;\r\n    }\r\n\r\n    if (!settings.input) {\r\n        throw new Error(\"input undefined\");\r\n    }\r\n\r\n    const input: HTMLInputElement = settings.input;\r\n\r\n    container.className = \"autocomplete \" + (settings.className || \"\");\r\n\r\n    // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\r\n    containerStyle.position = \"absolute\";\r\n\r\n    /**\r\n     * Detach the container from DOM\r\n     */\r\n    function detach(): void {\r\n        const parent = container.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\r\n    function clearDebounceTimer(): void {\r\n        if (debounceTimer) {\r\n            window.clearTimeout(debounceTimer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the container to DOM\r\n     */\r\n    function attach(): void {\r\n        if (!container.parentNode) {\r\n            doc.body.appendChild(container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\r\n    function containerDisplayed(): boolean {\r\n        return !!container.parentNode;\r\n    }\r\n\r\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\r\n    function clear(): void {\r\n        // prevent the update call if there are pending AJAX requests\r\n        keypressCounter++;\r\n        \r\n        items = [];\r\n        inputValue = \"\";\r\n        selected = undefined;\r\n        detach();\r\n    }\r\n\r\n    /**\r\n     * Update autocomplete position\r\n     */\r\n    function updatePosition(): void {\r\n        if (!containerDisplayed()) {\r\n            return;\r\n        }\r\n\r\n        containerStyle.height = \"auto\";\r\n        containerStyle.width = input.offsetWidth + \"px\";\r\n\r\n        let maxHeight = 0;\r\n        let inputRect: ClientRect | DOMRect | undefined;\r\n\r\n        function calc() {\r\n            const docEl = doc.documentElement as HTMLElement;\r\n            const clientTop = docEl.clientTop || doc.body.clientTop || 0;\r\n            const clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;\r\n            const scrollTop = window.pageYOffset || docEl.scrollTop;\r\n            const scrollLeft = window.pageXOffset || docEl.scrollLeft;\r\n\r\n            inputRect = input.getBoundingClientRect();\r\n        \r\n            const top = inputRect.top + input.offsetHeight + scrollTop - clientTop;\r\n            const left = inputRect.left + scrollLeft - clientLeft;\r\n    \r\n            containerStyle.top = top + \"px\";\r\n            containerStyle.left = left + \"px\";\r\n    \r\n            maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\r\n    \r\n            if (maxHeight < 0) {\r\n                maxHeight = 0;\r\n            }\r\n    \r\n            containerStyle.top = top + \"px\";\r\n            containerStyle.bottom = \"\";\r\n            containerStyle.left = left + \"px\";\r\n            containerStyle.maxHeight = maxHeight + \"px\";\r\n        }\r\n\r\n        // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)\r\n        calc();\r\n        calc();\r\n\r\n        if (settings.customize && inputRect) {\r\n            settings.customize(input, inputRect, container, maxHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\r\n    function update(): void {\r\n        \r\n        // delete all children from autocomplete DOM container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n\r\n        // function for rendering autocomplete suggestions\r\n        let render = function(item: T, currentValue: string): HTMLDivElement | undefined {\r\n            const itemElement = doc.createElement(\"div\");\r\n            itemElement.textContent = item.label || \"\";\r\n            return itemElement;\r\n        };\r\n        if (settings.render) {\r\n            render = settings.render;\r\n        }\r\n\r\n        // function to render autocomplete groups\r\n        let renderGroup = function(groupName: string, currentValue: string): HTMLDivElement | undefined {\r\n            const groupDiv = doc.createElement(\"div\");\r\n            groupDiv.textContent = groupName;\r\n            return groupDiv;\r\n        };\r\n        if (settings.renderGroup) {\r\n            renderGroup = settings.renderGroup;\r\n        }\r\n\r\n        const fragment = doc.createDocumentFragment();\r\n        let prevGroup = \"#9?$\";\r\n\r\n        items.forEach(function(item: T): void {\r\n            if (item.group && item.group !== prevGroup) {\r\n                prevGroup = item.group;\r\n                const groupDiv = renderGroup(item.group, inputValue);\r\n                if (groupDiv) {\r\n                    groupDiv.className += \" group\";\r\n                    fragment.appendChild(groupDiv);\r\n                }\r\n            }\r\n            const div = render(item, inputValue);\r\n            if (div) {\r\n                div.addEventListener(\"click\", function(ev: MouseEvent): void {\r\n                    settings.onSelect(item, input);\r\n                    clear();\r\n                    ev.preventDefault();\r\n                    ev.stopPropagation();\r\n                });\r\n                if (item === selected) {\r\n                    div.className += \" selected\";\r\n                }\r\n                fragment.appendChild(div);\r\n            }\r\n        });\r\n        container.appendChild(fragment);\r\n        if (items.length < 1) {\r\n            if (settings.emptyMsg) {\r\n                const empty = doc.createElement(\"div\");\r\n                empty.className = \"empty\";\r\n                empty.textContent = settings.emptyMsg;\r\n                container.appendChild(empty);\r\n            } else {\r\n                clear();\r\n                return;\r\n            }\r\n        }\r\n\r\n        attach();\r\n        updatePosition();\r\n\r\n        updateScroll();\r\n    }\r\n\r\n    function updateIfDisplayed(): void {\r\n        if (containerDisplayed()) {\r\n            update();\r\n        }\r\n    }\r\n\r\n    function resizeEventHandler(): void {\r\n        updateIfDisplayed();\r\n    }\r\n\r\n    function scrollEventHandler(e: Event): void {\r\n        if (e.target !== container) {\r\n            updateIfDisplayed();\r\n        } else {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    function keyupEventHandler(ev: KeyboardEvent): void {\r\n        const keyCode = ev.which || ev.keyCode || 0;\r\n\r\n        const ignore = [Keys.Up, Keys.Enter, Keys.Esc, Keys.Right, Keys.Left, Keys.Shift, Keys.Ctrl, Keys.Alt, Keys.CapsLock, Keys.WindowsKey, Keys.Tab];\r\n        for (const key of ignore) {\r\n            if (keyCode === key) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (keyCode >= Keys.F1 && keyCode <= Keys.F12) {\r\n            return;\r\n        }\r\n\r\n        // the down key is used to open autocomplete\r\n        if (keyCode === Keys.Down && containerDisplayed()) {\r\n            return;\r\n        }\r\n\r\n        startFetch(EventTrigger.Keyboard);\r\n    }\r\n\r\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\r\n    function updateScroll(): void {\r\n        const elements = container.getElementsByClassName(\"selected\");\r\n        if (elements.length > 0) {\r\n            let element = elements[0] as HTMLDivElement;\r\n            \r\n            // make group visible\r\n            const previous = element.previousElementSibling as HTMLDivElement;\r\n            if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\r\n                element = previous;\r\n            }\r\n\r\n            if (element.offsetTop < container.scrollTop) {\r\n                container.scrollTop = element.offsetTop;\r\n            } else {\r\n                const selectBottom = element.offsetTop + element.offsetHeight;\r\n                const containerBottom = container.scrollTop + container.offsetHeight;\r\n                if (selectBottom > containerBottom) {\r\n                    container.scrollTop += selectBottom - containerBottom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select the previous item in suggestions\r\n     */\r\n    function selectPrev(): void {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        } else {\r\n            if (selected === items[0]) {\r\n                selected = items[items.length - 1];\r\n            } else {\r\n                for (let i = items.length - 1; i > 0; i--) {\r\n                    if (selected === items[i] || i === 1) {\r\n                        selected = items[i - 1];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select the next item in suggestions\r\n     */\r\n    function selectNext(): void {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        if (!selected || selected === items[items.length - 1]) {\r\n            selected = items[0];\r\n            return;\r\n        }\r\n        for (let i = 0; i < (items.length - 1); i++) {\r\n            if (selected === items[i]) {\r\n                selected = items[i + 1];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function keydownEventHandler(ev: KeyboardEvent): void {\r\n        const keyCode = ev.which || ev.keyCode || 0;\r\n\r\n        if (keyCode === Keys.Up || keyCode === Keys.Down || keyCode === Keys.Esc) {\r\n            const containerIsDisplayed = containerDisplayed();\r\n\r\n            if (keyCode === Keys.Esc) {\r\n                clear();\r\n            } else {\r\n                if (!containerIsDisplayed || items.length < 1) {\r\n                    return;\r\n                }\r\n                keyCode === Keys.Up\r\n                    ? selectPrev()\r\n                    : selectNext();\r\n                update();\r\n            }\r\n\r\n            ev.preventDefault();\r\n            if (containerIsDisplayed) {\r\n                ev.stopPropagation();\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (keyCode === Keys.Enter) {\r\n            if (selected) {\r\n                settings.onSelect(selected, input);\r\n                clear();\r\n            }\r\n    \r\n            if (preventSubmit) {\r\n                ev.preventDefault();\r\n            }\r\n        }\r\n    }\r\n\r\n    function focusEventHandler(): void {\r\n        if (showOnFocus) {\r\n            startFetch(EventTrigger.Focus);\r\n        }\r\n    }\r\n\r\n    function startFetch(trigger: EventTrigger) {\r\n        // If multiple keys were pressed, before we get an update from server,\r\n        // this may cause redrawing autocomplete multiple times after the last key was pressed.\r\n        // To avoid this, the number of times keyboard was pressed will be saved and checked before redraw.\r\n        const savedKeypressCounter = ++keypressCounter;\r\n\r\n        const val = input.value;\r\n        if (val.length >= minLen || trigger === EventTrigger.Focus) {\r\n            clearDebounceTimer();\r\n            debounceTimer = window.setTimeout(function(): void {\r\n                settings.fetch(val, function(elements: T[] | false): void {\r\n                    if (keypressCounter === savedKeypressCounter && elements) {\r\n                        items = elements;\r\n                        inputValue = val;\r\n                        selected = (items.length < 1 || disableAutoSelect) ? undefined : items[0];\r\n                        update();\r\n                    }\r\n                }, trigger);\r\n            }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);\r\n        } else {\r\n            clear();\r\n        }\r\n    }\r\n\r\n    function blurEventHandler(): void {\r\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\r\n        setTimeout(() => {\r\n            if (doc.activeElement !== input) {\r\n                clear();\r\n            }\r\n        }, 200);\r\n    }\r\n\r\n    /**\r\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\r\n     */\r\n    container.addEventListener(\"mousedown\", function(evt: Event) {\r\n        evt.stopPropagation();\r\n        evt.preventDefault();\r\n    });\r\n\r\n    /**\r\n     * Fixes #30: autocomplete closes when scrollbar is clicked in IE\r\n     * See: https://stackoverflow.com/a/9210267/13172349\r\n     */\r\n    container.addEventListener(\"focus\", () => input.focus());\r\n\r\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\r\n    function destroy(): void {\r\n        input.removeEventListener(\"focus\", focusEventHandler);\r\n        input.removeEventListener(\"keydown\", keydownEventHandler);\r\n        input.removeEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\r\n        input.removeEventListener(\"blur\", blurEventHandler);\r\n        window.removeEventListener(\"resize\", resizeEventHandler);\r\n        doc.removeEventListener(\"scroll\", scrollEventHandler, true);\r\n        clearDebounceTimer();\r\n        clear();\r\n    }\r\n\r\n    // setup event handlers\r\n    input.addEventListener(\"keydown\", keydownEventHandler);\r\n    input.addEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\r\n    input.addEventListener(\"blur\", blurEventHandler);\r\n    input.addEventListener(\"focus\", focusEventHandler);\r\n    window.addEventListener(\"resize\", resizeEventHandler);\r\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\r\n\r\n    return {\r\n        destroy\r\n    };\r\n}\r\n"]},"metadata":{},"sourceType":"script"}